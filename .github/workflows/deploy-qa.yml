name: Deploy to QA on Main Push

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  deploy-to-qa:
    name: Deploy to QA Org
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Install Salesforce CLI
        run: |
          npm install -g @salesforce/cli
          sf version

      - name: Install SFDX Git Delta
        run: |
          npm install -g sfdx-git-delta
          echo "y" | sfdx plugins:install sfdx-git-delta

      - name: Authenticate to QA Org
        run: |
          echo "${{ secrets.SF_QA_AUTH_URL }}" > qa-auth.txt
          sf org login sfdx-url --sfdx-url-file qa-auth.txt --set-default --alias qaOrg
          sf org display user --target-org qaOrg
          rm qa-auth.txt

      - name: Generate Delta Package
        run: |
          echo "üì¶ Generating delta package for changed components..."
          
          # Check if there's a previous QA deployment tag
          LAST_QA_TAG=$(git tag -l "qa-deploy-*" | sort -V | tail -n 1)
          
          if [ -z "$LAST_QA_TAG" ]; then
            echo "‚ö†Ô∏è No previous QA deployment tag found"
            echo "FIRST_DEPLOY=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "Last QA deployment: $LAST_QA_TAG"
          echo "Comparing from $LAST_QA_TAG to HEAD..."
          
          sfdx sgd:source:delta --to HEAD --from "$LAST_QA_TAG" --output . --generate-delta --source force-app
          
          echo "Changed components:"
          if [ -f package/package.xml ]; then
            cat package/package.xml
          else
            echo "‚ö†Ô∏è No metadata changes detected"
          fi

      - name: Read test classes from manifest
        id: read-tests
        run: |
          if [ ! -f ".github/tests/test-classes.txt" ]; then
            echo "‚ùå Test manifest not found at .github/tests/test-classes.txt"
            exit 1
          fi
          
          TEST_CLASSES=$(cat .github/tests/test-classes.txt | grep -v '^$' | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "test_classes=$TEST_CLASSES" >> $GITHUB_OUTPUT
          echo "üìã Tests to run: $TEST_CLASSES"
          echo "üìã Test count: $(cat .github/tests/test-classes.txt | grep -v '^$' | sort -u | wc -l)"

      - name: Deploy to QA (without running tests during deployment)
        run: |
          # If this is the first deployment, deploy everything
          if [ "$FIRST_DEPLOY" = "true" ]; then
            echo "üöÄ First QA deployment - deploying all metadata from force-app..."
            sf project deploy start --target-org qaOrg --source-dir force-app --wait 30 --test-level NoTestRun
            exit 0
          fi
          
          # Otherwise deploy delta
          if [ ! -f package/package.xml ]; then
            echo "‚ö†Ô∏è No metadata changes to deploy, skipping deployment..."
            echo "SKIP_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi
          
          # Check if package.xml has any actual components
          if ! grep -q "<types>" package/package.xml; then
            echo "‚ö†Ô∏è Package.xml is empty, no components to deploy, skipping..."
            echo "SKIP_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "üöÄ Deploying only changed metadata to QA..."
          sf project deploy start --target-org qaOrg --manifest package/package.xml --wait 30 --test-level NoTestRun

      - name: Run specified tests WITH coverage
        if: env.SKIP_TESTS != 'true'
        id: run-coverage
        run: |
          echo "üß™ Running specified tests with code coverage..."
          
          # Build test arguments
          TEST_ARGS=""
          IFS=',' read -ra TESTS <<< "${{ steps.read-tests.outputs.test_classes }}"
          for test in "${TESTS[@]}"; do
            TEST_ARGS="$TEST_ARGS --tests $test"
          done
          
          echo "Test arguments: $TEST_ARGS"
          
          sf apex run test --target-org qaOrg \
            $TEST_ARGS \
            --wait 10 \
            --result-format json \
            --code-coverage > test-results.json
          
          cat test-results.json

      - name: Validate code coverage (must be ‚â• ${{ vars.COVERAGE_TARGET }}%)
        if: env.SKIP_TESTS != 'true'
        run: |
          echo "üìä Checking test run coverage against target: ${{ vars.COVERAGE_TARGET || 75 }}%"

          if [ ! -f test-results.json ]; then
            echo "‚ùå test-results.json file not found!"
            exit 1
          fi

          # Extract test run coverage
          TEST_RUN=$(jq -r '.result.summary.testRunCoverage' test-results.json)
          ORG_WIDE=$(jq -r '.result.summary.orgWideCoverage' test-results.json)

          echo "üß™ Test run coverage: $TEST_RUN"
          echo "üèõÔ∏è Org-wide coverage: $ORG_WIDE"

          # Convert TEST_RUN to numeric
          COVERAGE_NUM=$(echo "$TEST_RUN" | tr -d '%')
          THRESHOLD=${{ vars.COVERAGE_TARGET || 75 }}

          if (( $(echo "$COVERAGE_NUM < $THRESHOLD" | bc -l) )); then
            echo "‚ùå Coverage ($TEST_RUN) is below threshold ($THRESHOLD%)"
            exit 1
          else
            echo "‚úÖ Coverage check passed ($TEST_RUN ‚â• $THRESHOLD%)"
          fi

      - name: Tag Successful Deployment
        if: success()
        run: |
          QA_TAG="qa-deploy-$(date +'%Y%m%d-%H%M%S')"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "$QA_TAG"
          git push origin "$QA_TAG"
          echo "‚úÖ QA deployment tagged: $QA_TAG"

      - name: Deployment Success
        if: success() && env.SKIP_TESTS != 'true'
        run: |
          TEST_RUN=$(jq -r '.result.summary.testRunCoverage' test-results.json)
          ORG_WIDE=$(jq -r '.result.summary.orgWideCoverage' test-results.json)
          THRESHOLD=${{ vars.COVERAGE_TARGET || 75 }}
          echo "‚úÖ QA deployment completed successfully!"
          echo "üìä Test Run Coverage: $TEST_RUN (Target: ‚â•${THRESHOLD}%)"
          echo "üìä Org-wide Coverage: $ORG_WIDE"

update-jira-ticket:
    name: Move Jira Ticket to QA
    runs-on: ubuntu-latest
    needs: deploy-to-qa
    if: success()
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 10

      - name: Get branch name from commit history
        id: branch-info
        run: |
          # Get the commit message which might contain branch info
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "Commit message: $COMMIT_MSG"
          
          # Try to find branch name from recent merge commits
          BRANCH_NAME=$(git log --merges -10 --pretty=format:"%s" | grep -oP "Merge pull request #\d+ from [^/]+/\K.+" | head -1)
          
          if [ -z "$BRANCH_NAME" ]; then
            # Alternative: check git reflog for branch info
            BRANCH_NAME=$(git reflog show --pretty=format:"%gs" -10 | grep -oP "merge \K[^ ]+" | grep -v "^origin/" | head -1)
          fi
          
          if [ -z "$BRANCH_NAME" ]; then
            echo "Could not find branch name from git history"
            echo "HAS_BRANCH=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Clean up branch name (remove origin/ if present)
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's|^origin/||')
          
          echo "Found branch name: $BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "HAS_BRANCH=true" >> $GITHUB_OUTPUT

      - name: Extract Jira Ticket from Branch Name
        if: steps.branch-info.outputs.HAS_BRANCH == 'true'
        id: jira
        run: |
          BRANCH_NAME="${{ steps.branch-info.outputs.branch_name }}"
          echo "Branch name: $BRANCH_NAME"
          
          # Extract ticket number (e.g., HL-328 from HL-328_fix_bug)
          if [[ $BRANCH_NAME =~ ^([A-Z]+-[0-9]+)_ ]]; then
            TICKET="${BASH_REMATCH[1]}"
            echo "Found Jira ticket: $TICKET"
            echo "ticket=$TICKET" >> $GITHUB_OUTPUT
            echo "HAS_TICKET=true" >> $GITHUB_OUTPUT
          else
            echo "No Jira ticket found in branch name: $BRANCH_NAME"
            echo "HAS_TICKET=false" >> $GITHUB_OUTPUT
          fi

      - name: Update Jira Ticket Status
        if: steps.jira.outputs.HAS_TICKET == 'true'
        run: |
          TICKET="${{ steps.jira.outputs.ticket }}"
          JIRA_URL="${{ secrets.JIRA_URL }}"
          JIRA_EMAIL="${{ secrets.JIRA_EMAIL }}"
          JIRA_API_TOKEN="${{ secrets.JIRA_API_TOKEN }}"
          
          echo "Moving $TICKET to QA status..."
          
          # Get available transitions for the ticket
          TRANSITIONS=$(curl -s -u "$JIRA_EMAIL:$JIRA_API_TOKEN" \
            -X GET \
            -H "Content-Type: application/json" \
            "$JIRA_URL/rest/api/3/issue/$TICKET/transitions")
          
          # Find the transition ID for "QA" or "In QA" status
          TRANSITION_ID=$(echo "$TRANSITIONS" | jq -r '.transitions[] | select(.name | test("QA"; "i")) | .id' | head -1)
          
          if [ -z "$TRANSITION_ID" ]; then
            echo "‚ö†Ô∏è Could not find 'QA' transition for ticket $TICKET"
            echo "Available transitions:"
            echo "$TRANSITIONS" | jq -r '.transitions[] | "\(.id): \(.name)"'
            exit 0
          fi
          
          echo "Using transition ID: $TRANSITION_ID"
          
          # Transition the ticket
          RESPONSE=$(curl -s -u "$JIRA_EMAIL:$JIRA_API_TOKEN" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "{\"transition\":{\"id\":\"$TRANSITION_ID\"}}" \
            "$JIRA_URL/rest/api/3/issue/$TICKET/transitions")
          
          if [ -z "$RESPONSE" ]; then
            echo "‚úÖ Successfully moved $TICKET to QA status"
          else
            echo "Response: $RESPONSE"
            echo "‚ö†Ô∏è Jira update may have failed, but continuing..."
          fi

      - name: Add Comment to Jira Ticket
        if: steps.jira.outputs.HAS_TICKET == 'true'
        run: |
          TICKET="${{ steps.jira.outputs.ticket }}"
          JIRA_URL="${{ secrets.JIRA_URL }}"
          JIRA_EMAIL="${{ secrets.JIRA_EMAIL }}"
          JIRA_API_TOKEN="${{ secrets.JIRA_API_TOKEN }}"
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA="${COMMIT_SHA:0:7}"
          COMMIT_URL="https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
          
          COMMENT=$(cat <<'EOF'
          {
            "body": {
              "type": "doc",
              "version": 1,
              "content": [
                {
                  "type": "paragraph",
                  "content": [
                    {
                      "type": "text",
                      "text": "‚úÖ Code deployed to QA",
                      "marks": [{"type": "strong"}]
                    }
                  ]
                },
                {
                  "type": "paragraph",
                  "content": [
                    {
                      "type": "text",
                      "text": "Commit: "
                    },
                    {
                      "type": "text",
                      "text": "SHORT_SHA_PLACEHOLDER",
                      "marks": [
                        {
                          "type": "link",
                          "attrs": {
                            "href": "COMMIT_URL_PLACEHOLDER"
                          }
                        }
                      ]
                    }
                  ]
                },
                {
                  "type": "paragraph",
                  "content": [
                    {
                      "type": "text",
                      "text": "Deployed by: ACTOR_PLACEHOLDER"
                    }
                  ]
                }
              ]
            }
          }
EOF
          )
          
          # Replace placeholders
          COMMENT=$(echo "$COMMENT" | sed "s|SHORT_SHA_PLACEHOLDER|$SHORT_SHA|g")
          COMMENT=$(echo "$COMMENT" | sed "s|COMMIT_URL_PLACEHOLDER|$COMMIT_URL|g")
          COMMENT=$(echo "$COMMENT" | sed "s|ACTOR_PLACEHOLDER|${{ github.actor }}|g")
          
          curl -s -u "$JIRA_EMAIL:$JIRA_API_TOKEN" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "$COMMENT" \
            "$JIRA_URL/rest/api/3/issue/$TICKET/comment"
          
          echo "‚úÖ Added comment to $TICKET"