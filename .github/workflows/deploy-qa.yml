name: Deploy to QA on Main Push

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  deploy-to-qa:
    name: Deploy to QA Org
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Install Salesforce CLI
        run: |
          npm install -g @salesforce/cli
          sf version

      - name: Install SFDX Git Delta
        run: |
          npm install -g sfdx-git-delta
          echo "y" | sfdx plugins:install sfdx-git-delta

      - name: Authenticate to QA Org
        run: |
          echo "${{ secrets.SF_QA_AUTH_URL }}" > qa-auth.txt
          sf org login sfdx-url --sfdx-url-file qa-auth.txt --set-default --alias qaOrg
          sf org display user --target-org qaOrg
          rm qa-auth.txt

      - name: Generate Delta Package
        run: |
          echo "üì¶ Generating delta package for changed components..."
          
          LAST_QA_TAG=$(git tag -l "qa-deploy-*" | sort -V | tail -n 1)
          
          if [ -z "$LAST_QA_TAG" ]; then
            echo "‚ö†Ô∏è No previous QA deployment tag found"
            echo "FIRST_DEPLOY=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "Last QA deployment: $LAST_QA_TAG"
          echo "Comparing from $LAST_QA_TAG to HEAD..."
          
          sfdx sgd:source:delta --to HEAD --from "$LAST_QA_TAG" --output . --generate-delta --source force-app
          
          echo "Changed components:"
          if [ -f package/package.xml ]; then
            cat package/package.xml
          else
            echo "‚ö†Ô∏è No metadata changes detected"
          fi

      - name: Read test classes from manifest
        id: read-tests
        run: |
          if [ ! -f ".github/tests/test-classes.txt" ]; then
            echo "‚ùå Test manifest not found at .github/tests/test-classes.txt"
            exit 1
          fi
          
          TEST_CLASSES=$(cat .github/tests/test-classes.txt | grep -v '^$' | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "test_classes=$TEST_CLASSES" >> $GITHUB_OUTPUT
          echo "üìã Tests to run: $TEST_CLASSES"
          echo "üìã Test count: $(cat .github/tests/test-classes.txt | grep -v '^$' | sort -u | wc -l)"

      - name: Deploy to QA (without running tests during deployment)
        run: |
          if [ "$FIRST_DEPLOY" = "true" ]; then
            echo "üöÄ First QA deployment - deploying all metadata from force-app..."
            sf project deploy start --target-org qaOrg --source-dir force-app --wait 30 --test-level NoTestRun
            exit 0
          fi
          
          if [ ! -f package/package.xml ]; then
            echo "‚ö†Ô∏è No metadata changes to deploy, skipping deployment..."
            echo "SKIP_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi
          
          if ! grep -q "<types>" package/package.xml; then
            echo "‚ö†Ô∏è Package.xml is empty, no components to deploy, skipping..."
            echo "SKIP_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "üöÄ Deploying only changed metadata to QA..."
          sf project deploy start --target-org qaOrg --manifest package/package.xml --wait 30 --test-level NoTestRun

      - name: Run specified tests WITH coverage
        if: env.SKIP_TESTS != 'true'
        id: run-coverage
        run: |
          echo "üß™ Running specified tests with code coverage..."
          
          TEST_ARGS=""
          IFS=',' read -ra TESTS <<< "${{ steps.read-tests.outputs.test_classes }}"
          for test in "${TESTS[@]}"; do
            TEST_ARGS="$TEST_ARGS --tests $test"
          done
          
          echo "Test arguments: $TEST_ARGS"
          
          sf apex run test --target-org qaOrg \
            $TEST_ARGS \
            --wait 10 \
            --result-format json \
            --code-coverage > test-results.json
          
          cat test-results.json

      - name: Validate code coverage (must be ‚â• ${{ vars.COVERAGE_TARGET }}%)
        if: env.SKIP_TESTS != 'true'
        run: |
          echo "üìä Checking test run coverage against target: ${{ vars.COVERAGE_TARGET || 75 }}%"

          if [ ! -f test-results.json ]; then
            echo "‚ùå test-results.json file not found!"
            exit 1
          fi

          TEST_RUN=$(jq -r '.result.summary.testRunCoverage' test-results.json)
          ORG_WIDE=$(jq -r '.result.summary.orgWideCoverage' test-results.json)

          echo "üß™ Test run coverage: $TEST_RUN"
          echo "üèõÔ∏è Org-wide coverage: $ORG_WIDE"

          COVERAGE_NUM=$(echo "$TEST_RUN" | tr -d '%')
          THRESHOLD=${{ vars.COVERAGE_TARGET || 75 }}

          if (( $(echo "$COVERAGE_NUM < $THRESHOLD" | bc -l) )); then
            echo "‚ùå Coverage ($TEST_RUN) is below threshold ($THRESHOLD%)"
            exit 1
          else
            echo "‚úÖ Coverage check passed ($TEST_RUN ‚â• $THRESHOLD%)"
          fi

      - name: Tag Successful Deployment
        if: success()
        run: |
          QA_TAG="qa-deploy-$(date +'%Y%m%d-%H%M%S')"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "$QA_TAG"
          git push origin "$QA_TAG"
          echo "‚úÖ QA deployment tagged: $QA_TAG"

      - name: Deployment Success
        if: success() && env.SKIP_TESTS != 'true'
        run: |
          TEST_RUN=$(jq -r '.result.summary.testRunCoverage' test-results.json)
          ORG_WIDE=$(jq -r '.result.summary.orgWideCoverage' test-results.json)
          THRESHOLD=${{ vars.COVERAGE_TARGET || 75 }}
          echo "‚úÖ QA deployment completed successfully!"
          echo "üìä Test Run Coverage: $TEST_RUN (Target: ‚â•${THRESHOLD}%)"
          echo "üìä Org-wide Coverage: $ORG_WIDE"

  update-jira-ticket:
    name: Move Jira Ticket to QA
    runs-on: ubuntu-latest
    needs: deploy-to-qa
    if: success()

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 10

      - name: Get branch name from commit history
        id: branch-info
        run: |
          echo "üîç Searching for feature branch in THIS deployment..."
          
          LAST_QA_TAG=$(git tag -l "qa-deploy-*" | sort -V | tail -n 1)
          
          if [ -z "$LAST_QA_TAG" ]; then
            SEARCH_RANGE="HEAD~10..HEAD"
          else
            SEARCH_RANGE="${LAST_QA_TAG}..HEAD"
          fi
          
          echo "Searching commits in range: $SEARCH_RANGE"
          
          BRANCH_NAME=$(git log $SEARCH_RANGE --merges --pretty=format:"%s" | \
            grep -oP "Merge (pull request #\d+ from [^/]+/|branch ')\K[^'/)]+(?=('| into))" | \
            grep -v "^release$" | \
            grep -v "^main$" | \
            head -1)
          
          if [ -z "$BRANCH_NAME" ]; then
            BRANCH_NAME=$(git log $SEARCH_RANGE --pretty=format:"%s %b" | \
              grep -oP "\b([A-Z]+-[0-9]+_[a-zA-Z0-9_-]+)\b" | \
              head -1)
          fi
          
          if [ -z "$BRANCH_NAME" ]; then
            echo "‚ùå Could not find feature branch name from git history"
            echo ""
            echo "üìã Commits in this deployment:"
            git log $SEARCH_RANGE --pretty=format:"%h - %s"
            echo ""
            echo "HAS_BRANCH=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's|^origin/||' | sed 's|^refs/heads/||')
          
          echo "‚úÖ Found feature branch in this deployment: $BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "HAS_BRANCH=true" >> $GITHUB_OUTPUT

      - name: Extract Jira Ticket from Branch Name
        if: steps.branch-info.outputs.HAS_BRANCH == 'true'
        id: jira
        run: |
          BRANCH_NAME="${{ steps.branch-info.outputs.branch_name }}"
          echo "üé´ Checking branch name: $BRANCH_NAME"
          
          if [[ $BRANCH_NAME =~ ^([A-Z]+-[0-9]+)_ ]]; then
            TICKET="${BASH_REMATCH[1]}"
            echo "‚úÖ Found Jira ticket: $TICKET"
            echo "ticket=$TICKET" >> $GITHUB_OUTPUT
            echo "HAS_TICKET=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No Jira ticket found in branch name: $BRANCH_NAME"
            echo "HAS_TICKET=false" >> $GITHUB_OUTPUT
          fi

      - name: Update Jira Ticket Status
        if: steps.jira.outputs.HAS_TICKET == 'true'
        run: |
          TICKET="${{ steps.jira.outputs.ticket }}"
          JIRA_URL="${{ secrets.JIRA_URL }}"
          JIRA_EMAIL="${{ secrets.JIRA_EMAIL }}"
          JIRA_API_TOKEN="${{ secrets.JIRA_API_TOKEN }}"
          
          echo "üîÑ Moving $TICKET to QA status..."
          
          TRANSITIONS=$(curl -s -u "$JIRA_EMAIL:$JIRA_API_TOKEN" \
            -X GET \
            -H "Content-Type: application/json" \
            "$JIRA_URL/rest/api/3/issue/$TICKET/transitions")
          
          TRANSITION_ID=$(echo "$TRANSITIONS" | jq -r '.transitions[] | select(.name | test("QA"; "i")) | .id' | head -1)
          
          if [ -z "$TRANSITION_ID" ]; then
            echo "‚ö†Ô∏è Could not find 'QA' transition for ticket $TICKET"
            echo "Available transitions:"
            echo "$TRANSITIONS" | jq -r '.transitions[] | "\(.id): \(.name)"'
            exit 0
          fi
          
          echo "Using transition ID: $TRANSITION_ID"
          
          RESPONSE=$(curl -s -u "$JIRA_EMAIL:$JIRA_API_TOKEN" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "{\"transition\":{\"id\":\"$TRANSITION_ID\"}}" \
            "$JIRA_URL/rest/api/3/issue/$TICKET/transitions")
          
          if [ -z "$RESPONSE" ]; then
            echo "‚úÖ Successfully moved $TICKET to QA status"
          else
            echo "Response: $RESPONSE"
            echo "‚ö†Ô∏è Jira update may have failed, but continuing..."
          fi

      - name: Add Comment to Jira Ticket
        if: steps.jira.outputs.HAS_TICKET == 'true'
        run: |
          TICKET="${{ steps.jira.outputs.ticket }}"
          JIRA_URL="${{ secrets.JIRA_URL }}"
          JIRA_EMAIL="${{ secrets.JIRA_EMAIL }}"
          JIRA_API_TOKEN="${{ secrets.JIRA_API_TOKEN }}"
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA="${COMMIT_SHA:0:7}"
          COMMIT_URL="https://github.com/${{ github.repository }}/commit/$COMMIT_SHA"
          ACTOR="${{ github.actor }}"
          
          COMMENT='{"body":{"type":"doc","version":1,"content":[{"type":"paragraph","content":[{"type":"text","text":"‚úÖ Code deployed to QA","marks":[{"type":"strong"}]}]},{"type":"paragraph","content":[{"type":"text","text":"Commit: "},{"type":"text","text":"'"$SHORT_SHA"'","marks":[{"type":"link","attrs":{"href":"'"$COMMIT_URL"'"}}]}]},{"type":"paragraph","content":[{"type":"text","text":"Deployed by: '"$ACTOR"'"}]}]}}'
          
          curl -s -u "$JIRA_EMAIL:$JIRA_API_TOKEN" \
            -X POST \
            -H "Content-Type: application/json" \
            -d "$COMMENT" \
            "$JIRA_URL/rest/api/3/issue/$TICKET/comment"
          
          echo "‚úÖ Added comment to $TICKET"