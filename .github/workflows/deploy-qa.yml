name: Deploy to QA on Main Push

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  deploy-to-qa:
    name: Deploy to QA Org
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Install Salesforce CLI
        run: |
          npm install -g @salesforce/cli
          sf version

      - name: Install SFDX Git Delta
        run: |
          npm install -g sfdx-git-delta
          echo "y" | sfdx plugins:install sfdx-git-delta

      - name: Authenticate to QA Org
        run: |
          echo "${{ secrets.SF_QA_AUTH_URL }}" > qa-auth.txt
          sf org login sfdx-url --sfdx-url-file qa-auth.txt --set-default --alias qaOrg
          sf org display user --target-org qaOrg
          rm qa-auth.txt

      - name: Generate Delta Package
        run: |
          echo "ğŸ“¦ Generating delta package for changed components..."
          
          LAST_QA_TAG=$(git tag -l "qa-deploy-*" | sort -V | tail -n 1)
          
          if [ -z "$LAST_QA_TAG" ]; then
            echo "âš ï¸ No previous QA deployment tag found"
            echo "FIRST_DEPLOY=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "Last QA deployment: $LAST_QA_TAG"
          echo "Comparing from $LAST_QA_TAG to HEAD..."
          
          sfdx sgd:source:delta --to HEAD --from "$LAST_QA_TAG" --output . --generate-delta --source force-app
          
          echo "Changed components:"
          if [ -f package/package.xml ]; then
            cat package/package.xml
          else
            echo "âš ï¸ No metadata changes detected"
          fi

      - name: Read test classes from manifest
        id: read-tests
        run: |
          if [ ! -f ".github/tests/test-classes.txt" ]; then
            echo "âŒ Test manifest not found at .github/tests/test-classes.txt"
            exit 1
          fi
          
          TEST_CLASSES=$(cat .github/tests/test-classes.txt | grep -v '^$' | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "test_classes=$TEST_CLASSES" >> $GITHUB_OUTPUT
          echo "ğŸ“‹ Tests to run: $TEST_CLASSES"
          echo "ğŸ“‹ Test count: $(cat .github/tests/test-classes.txt | grep -v '^$' | sort -u | wc -l)"

      - name: Deploy to QA (without running tests during deployment)
        run: |
          if [ "$FIRST_DEPLOY" = "true" ]; then
            echo "ğŸš€ First QA deployment - deploying all metadata from force-app..."
            sf project deploy start --target-org qaOrg --source-dir force-app --wait 30 --test-level NoTestRun
            exit 0
          fi
          
          if [ ! -f package/package.xml ]; then
            echo "âš ï¸ No metadata changes to deploy, skipping deployment..."
            echo "SKIP_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi
          
          if ! grep -q "<types>" package/package.xml; then
            echo "âš ï¸ Package.xml is empty, no components to deploy, skipping..."
            echo "SKIP_TESTS=true" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "ğŸš€ Deploying only changed metadata to QA..."
          sf project deploy start --target-org qaOrg --manifest package/package.xml --wait 30 --test-level NoTestRun

      - name: Run specified tests WITH coverage
        if: env.SKIP_TESTS != 'true'
        id: run-coverage
        run: |
          echo "ğŸ§ª Running specified tests with code coverage..."
          
          TEST_ARGS=""
          IFS=',' read -ra TESTS <<< "${{ steps.read-tests.outputs.test_classes }}"
          for test in "${TESTS[@]}"; do
            TEST_ARGS="$TEST_ARGS --tests $test"
          done
          
          echo "Test arguments: $TEST_ARGS"
          
          sf apex run test --target-org qaOrg \
            $TEST_ARGS \
            --wait 10 \
            --result-format json \
            --code-coverage > test-results.json
          
          cat test-results.json

      - name: Validate code coverage (must be â‰¥ ${{ vars.COVERAGE_TARGET }}%)
        if: env.SKIP_TESTS != 'true'
        run: |
          echo "ğŸ“Š Checking test run coverage against target: ${{ vars.COVERAGE_TARGET || 75 }}%"

          if [ ! -f test-results.json ]; then
            echo "âŒ test-results.json file not found!"
            exit 1
          fi

          TEST_RUN=$(jq -r '.result.summary.testRunCoverage' test-results.json)
          ORG_WIDE=$(jq -r '.result.summary.orgWideCoverage' test-results.json)

          echo "ğŸ§ª Test run coverage: $TEST_RUN"
          echo "ğŸ›ï¸ Org-wide coverage: $ORG_WIDE"

          COVERAGE_NUM=$(echo "$TEST_RUN" | tr -d '%')
          THRESHOLD=${{ vars.COVERAGE_TARGET || 75 }}

          if (( $(echo "$COVERAGE_NUM < $THRESHOLD" | bc -l) )); then
            echo "âŒ Coverage ($TEST_RUN) is below threshold ($THRESHOLD%)"
            exit 1
          else
            echo "âœ… Coverage check passed ($TEST_RUN â‰¥ $THRESHOLD%)"
          fi

      - name: Tag Successful Deployment
        if: success()
        run: |
          QA_TAG="qa-deploy-$(date +'%Y%m%d-%H%M%S')"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag "$QA_TAG"
          git push origin "$QA_TAG"
          echo "âœ… QA deployment tagged: $QA_TAG"

      - name: Deployment Success
        if: success() && env.SKIP_TESTS != 'true'
        run: |
          TEST_RUN=$(jq -r '.result.summary.testRunCoverage' test-results.json)
          ORG_WIDE=$(jq -r '.result.summary.orgWideCoverage' test-results.json)
          THRESHOLD=${{ vars.COVERAGE_TARGET || 75 }}
          echo "âœ… QA deployment completed successfully!"
          echo "ğŸ“Š Test Run Coverage: $TEST_RUN (Target: â‰¥${THRESHOLD}%)"
          echo "ğŸ“Š Org-wide Coverage: $ORG_WIDE"

  update-jira-ticket:
    name: Move Jira Ticket to QA
    runs-on: ubuntu-latest
    needs: deploy-to-qa
    if: success()

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 10

      - name: Get branch name from commit history
        id: branch-info
        run: |
          echo "ğŸ” Searching for feature branch in THIS deployment..."
          
          # Get the previous QA deployment tag to know what's new
          LAST_QA_TAG=$(git tag -l "qa-deploy-*" | sort -V | tail -n 1)
          
          if [ -z "$LAST_QA_TAG" ]; then
            # First deployment - look at recent commits
            SEARCH_RANGE="HEAD~10..HEAD"
          else
            # Only look at commits since last QA deployment
            SEARCH_RANGE="${LAST_QA_TAG}..HEAD"
          fi
          
          echo "Searching commits in range: $SEARCH_RANGE"
          
          # Find feature branch in this range only
          BRANCH_NAME=$(git log $SEARCH_RANGE --merges --pretty=format:"%s" | \
            grep -oP "Merge (pull request #\d+ from [^/]+/|branch ')\K[^'/)]+(?=('| into))" | \
            grep -v "^release$" | \
            grep -v "^main$" | \
            head -1)
          
          if [ -z "$BRANCH_NAME" ]; then
            # Alternative: search commit messages in this range
            BRANCH_NAME=$(git log $SEARCH_RANGE --pretty=format:"%s %b" | \
              grep -oP "\b([A-Z]+-[0-9]+_[a-zA-Z0-9_-]+)\b" | \
              head -1)
          fi
          
          if [ -z "$BRANCH_NAME" ]; then
            echo "âŒ Could not find feature branch name from git history"
            echo ""
            echo "ğŸ“‹ Commits in this deployment:"
            git log $SEARCH_RANGE --pretty=format:"%h - %s"
            echo ""
            echo "HAS_BRANCH=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Clean up branch name
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's|^origin/||' | sed 's|^refs/heads/||')
          
          echo "âœ… Found feature branch in this deployment: $BRANCH_NAME"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "HAS_BRANCH=true" >> $GITHUB_OUTPUT
